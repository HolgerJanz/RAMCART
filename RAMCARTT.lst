mads 1.9.9
     1 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2 				; 
     3 				; Test Driver - The!Ramdisk for The!Cart
     4
     5 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6 				;
     7 				; The!Cart Equates
     8 				;
     9
    10 = D5A6			TCMOSL      = $d5a6     ; mode ($00-$3d,$01)
    11 = 00FF			TCMOSL.LOCK = $ff       ; config lock or not present
    12
    13 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14 				;
    15 				; Equates used to call CIO
    16 				;
    17
    18 = 00FE			XIO.FMT = 254   ; Format command
    19 = 0009			XIO.PRINT = 9   ; Print line
    20 = 0003			XIO.OPEN  = 3   ; Open
    21 = 000C			XIO.CLOSE = 12  ; Close
    22 = 0004			XIO.READ  = 4   ; Read
    23 = 0008			XIO.WRITE = 8   ; Write
    24 = 0007			XIO.GET   = 7   ; Get
    25 = 000B			XIO.PUT   = 11  ; Put
    26
    27 = 0340			IOCB        =  $0340    ; address of first IOCB
    28 = 0342			IOCB.CMD    = IOCB+2    ; where command goes in IOCB
    29 = 0344			IOCB.BUF    = IOCB+4    ; buffer (or name) address
    30 = 0348			IOCB.BUFLEN = IOCB+8    ; max buffer length address
    31 = 034A			IOCB.AUX1   = IOCB+10    ; Auxilliary byte 1
    32 = 034B			IOCB.AUX2   = IOCB+11    ; Auxilliary byte 2
    33
    34 = E456			CIOV = $E456   ; the classic location
    35
    36 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37 				;
    38 				; OS Equates
    39 				;
    40
    41 = 1481			RAMIO    = $1481     ; address of FMS RAMIO
    42 = 0304			DISKBUF  = $0304     ; buffer address for read/write
    43 = 030A			DCBSEC   = $030a     ; DAUX1,DAUX2 containing sector number
    44
    45 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    46 				; 
    47 				; RAMIO test switching with The!Cart
    48 				;
    49
    50 				        org $4000 
    51 				start                    ; Start of code
    52 				; check for The!Cart
    53 FFFF> 4000-42A9> AD A6 +         lda TCMOSL
    54 4003 C9 FF		        cmp #TCMOSL.LOCK
    55 4005 D0 0A		        bne start.ok
    56 4007 A2 C5		        ldx #<start.lock
    57 4009 A0 40		        ldy #>start.lock
    58 400B A9 13		        lda #start.lock.end-start.lock
    59 400D 20 11 42		        jsr print        
    60 4010 60			        rts
    61 				        
    62 4011			start.ok
    63 				; let's go
    64 4011 A2 D8		        ldx #<start.letsgo
    65 4013 A0 40		        ldy #>start.letsgo
    66 4015 A9 19		        lda #start.letsgo.end-start.letsgo
    67 4017 20 11 42		        jsr print                
    68
    69 				; write message
    70 401A A2 F1		        ldx #<start.write
    71 401C A0 40		        ldy #>start.write
    72 401E A9 06		        lda #start.write.end-start.write
    73 4020 20 11 42		        jsr print        
    74
    75 				; set buffer address for test frame
    76 4023 A9 2A		        lda #<RAMIO.SECBUF  ; set zero page address
    77 4025 85 CB		        sta RAMIO.SECPTR    ; to sector buffer
    78 4027 A9 42		        lda #>RAMIO.SECBUF
    79 4029 85 CC		        sta RAMIO.SECPTR+1
    80
    81 				; set buffer address for RAMIO
    82 402B A9 2A		        lda #<RAMIO.SECBUF  ; buffer address for read/write
    83 402D 8D 04 03		        sta DISKBUF         ; to sector buffer
    84 4030 A9 42		        lda #>RAMIO.SECBUF
    85 4032 8D 05 03		        sta DISKBUF+1
    86 				        
    87 				; init write loop message
    88 4035 A9 00		        lda #$00            ; start sector is 0
    89 4037 8D 0A 03		        sta DCBSEC
    90 403A 8D 0B 03		        sta DCBSEC+1
    91
    92 403D A2 06		        ldx #<start.counter.init ; init msg
    93 403F A0 41		        ldy #>start.counter.init
    94 4041 A9 0B		        lda #start.counter.init.end-start.counter.init
    95 4043 20 11 42		        jsr print        
    96
    97 				; ************************************************************
    98 4046			start.write.loop
    99 				; print sector number
   100 4046 20 D0 41		        jsr print.sector
   101 				; generate test data for sector
   102 4049 20 1F 41		        jsr testdata.generate
   103 				; call RAMIO to write sector to RAM disk
   104 404C 38			        sec
   105 404D 20 81 14		        jsr RAMIO
   106 				; increment sector count
   107 4050 18			        clc
   108 4051 A9 01		        lda #$01
   109 4053 6D 0A 03		        adc DCBSEC
   110 4056 8D 0A 03		        sta DCBSEC
   111 4059 A9 00		        lda #$00 
   112 405B 6D 0B 03		        adc DCBSEC+1
   113 405E 8D 0B 03		        sta DCBSEC+1
   114
   115 				; check sector count
   116 4061 A9 00		        lda #$00
   117 4063 CD 0A 03		        cmp DCBSEC
   118 4066 D0 DE		        bne start.write.loop
   119 4068 A9 10		        lda #$10
   120 406A CD 0B 03		        cmp DCBSEC+1
   121 406D D0 D7		        bne start.write.loop
   122 				; ************************************************************
   123
   124 				; write lf
   125 406F A2 11		        ldx #<start.counter.lf
   126 4071 A0 41		        ldy #>start.counter.lf
   127 4073 A9 01		        lda #start.counter.lf.end-start.counter.lf
   128 4075 20 11 42		        jsr print        
   129 				;*
   130 				;*
   131 				; ************************************************************
   132
   133 				; end of write, start read check
   134
   135 				; ************************************************************
   136 				;*
   137 				;*
   138
   139 				; check message
   140 4078 A2 F7		        ldx #<start.check
   141 407A A0 40		        ldy #>start.check
   142 407C A9 0F		        lda #start.check.end-start.check
   143 407E 20 11 42		        jsr print        
   144
   145 				; init check loop message
   146 4081 A9 00		        lda #$00            ; start sector is 0
   147 4083 8D 0A 03		        sta DCBSEC
   148 4086 8D 0B 03		        sta DCBSEC+1
   149
   150 4089 A2 06		        ldx #<start.counter.init ; init msg
   151 408B A0 41		        ldy #>start.counter.init
   152 408D A9 0B		        lda #start.counter.init.end-start.counter.init
   153 408F 20 11 42		        jsr print        
   154
   155 				; ************************************************************
   156 4092			start.check.loop
   157 				; print sector number
   158 4092 20 D0 41		        jsr print.sector
   159 				; call RAMIO to read sector from RAM disk
   160 4095 18			        clc
   161 4096 20 81 14		        jsr RAMIO
   162 				; check test data for sector
   163 4099 20 3B 41		        jsr testdata.check
   164
   165 				; increment sector count
   166 409C 18			        clc
   167 409D A9 01		        lda #$01
   168 409F 6D 0A 03		        adc DCBSEC
   169 40A2 8D 0A 03		        sta DCBSEC
   170 40A5 A9 00		        lda #$00 
   171 40A7 6D 0B 03		        adc DCBSEC+1
   172 40AA 8D 0B 03		        sta DCBSEC+1
   173
   174 				; check sector count
   175 40AD A9 00		        lda #$00
   176 40AF CD 0A 03		        cmp DCBSEC
   177 40B2 D0 DE		        bne start.check.loop
   178 40B4 A9 10		        lda #$10
   179 40B6 CD 0B 03		        cmp DCBSEC+1
   180 40B9 D0 D7		        bne start.check.loop
   181 				; ************************************************************
   182
   183 				; write lf
   184 40BB A2 11		        ldx #<start.counter.lf
   185 40BD A0 41		        ldy #>start.counter.lf
   186 40BF A9 01		        lda #start.counter.lf.end-start.counter.lf
   187 40C1 20 11 42		        jsr print        
   188
   189 40C4 60			        rts
   190
   191 40C5			start.lock
   192 40C5 54 48 45 21 43 41 +         .byte 'THE!CART NOT FOUND'
   193 40D7 9B			        .byte $9b
   194 40D8			start.lock.end
   195
   196 40D8			start.letsgo
   197 40D8 54 48 45 21 54 45 +         .byte 'THE!TEST FOR THE!RAMDISK'
   198 40F0 9B			        .byte $9b
   199 40F1			start.letsgo.end
   200
   201 40F1			start.write
   202 40F1 57 52 49 54 45	        .byte 'WRITE'
   203 40F6 9B			        .byte $9b
   204 40F7			start.write.end
   205
   206 40F7			start.check
   207 40F7 52 45 41 44 20 41 +         .byte 'READ AND CHECK'
   208 4105 9B			        .byte $9b
   209 4106			start.check.end
   210
   211 4106			start.counter.init
   212 4106 53 45 43 54 4F 52 +         .byte 'SECTOR ____'
   213 4111			start.counter.init.end
   214 4111			start.counter.lf
   215 4111 9B			        .byte $9b
   216 4112			start.counter.lf.end
   217
   218 4112			start.error
   219 4112 20 45 52 52 4F 52 +         .byte ' ERROR DUMP:'
   220 411E 9B			        .byte $9b
   221 411F			start.error.end
   222
   223 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   224 				; 
   225 				; Generate Test Date for Sector in 
   226 				;    IN    DCBSEC sector number
   227 				;        RAMIO.SECPTR buffer to sector buffer
   228 				;
   229
   230 411F			testdata.generate
   231 411F A0 00		        ldy #$00            ; set begin byte
   232 4121 A9 BB		        lda #$BB
   233 4123 91 CB		        sta (RAMIO.SECPTR),y
   234 				        
   235 4125 C8			        iny                 ; set high sec num (once)
   236 4126 AD 0B 03		        lda DCBSEC+1
   237 4129 91 CB		        sta (RAMIO.SECPTR),y
   238
   239 412B C8			        iny                 ; set fill bytes (low sec num)
   240 412C AD 0A 03		        lda DCBSEC
   241 412F			testdata.generate.loop
   242 412F 91 CB		        sta (RAMIO.SECPTR),y
   243 4131 C8			        iny
   244 4132 C0 7F		        cpy #$7f
   245 4134 D0 F9		        bne testdata.generate.loop
   246 				        
   247 4136 A9 EE		        lda #$EE            ; set end byte
   248 4138 91 CB		        sta (RAMIO.SECPTR),y
   249
   250 413A 60			        rts
   251
   252 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   253 				; 
   254 				; Check Test Date for Sector in 
   255 				;    IN    DCBSEC sector number
   256 				;        RAMIO.SECPTR buffer to sector buffer
   257 				;
   258
   259 413B			testdata.check
   260 413B A0 00		        ldy #$00            ; check begin byte
   261 413D B1 CB		        lda (RAMIO.SECPTR),y
   262 413F C9 BB		        cmp #$BB
   263 4141 D0 1C		        bne testdata.check.error
   264 				        
   265 4143 C8			        iny                 ; check high byte (sec num)
   266 4144 B1 CB		        lda (RAMIO.SECPTR),y
   267 4146 CD 0B 03		        cmp DCBSEC+1
   268 4149 D0 14		        bne testdata.check.error
   269 				        
   270 414B C8			        iny                 ; check fill bytes (low sec num)
   271 414C			testdata.check.loop
   272 414C B1 CB		        lda (RAMIO.SECPTR),y
   273 414E CD 0A 03		        cmp DCBSEC
   274 4151 D0 0C		        bne testdata.check.error
   275 4153 C8			        iny
   276 4154 C0 7F		        cpy #$7f
   277 4156 D0 F4		        bne testdata.check.loop
   278 				        
   279 4158 B1 CB		        lda (RAMIO.SECPTR),y ; check end byte
   280 415A C9 EE		        cmp #$EE
   281 415C D0 01		        bne testdata.check.error
   282
   283 415E 60			        rts
   284
   285 415F			testdata.check.error
   286 				; write error
   287 415F A2 12		        ldx #<start.error
   288 4161 A0 41		        ldy #>start.error
   289 4163 A9 0D		        lda #start.error.end-start.error
   290 4165 20 11 42		        jsr print        
   291 				; write sector data
   292 4168 20 75 41		        jsr print.data
   293 				; init next sector check msg
   294 416B A2 06		        ldx #<start.counter.init
   295 416D A0 41		        ldy #>start.counter.init
   296 416F A9 0B		        lda #start.counter.init.end-start.counter.init
   297 4171 20 11 42		        jsr print        
   298
   299 4174 60			        rts
   300
   301
   302 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   303 				; 
   304 				; Print Data
   305 				;
   306
   307 4175			print.data
   308 4175 A9 00		        lda #$00
   309 4177 8D AE 41		        sta print.data.loop.cnt
   310
   311 417A			print.data.loop
   312 				; get byte, conv ,and push
   313 417A AC AE 41		        ldy print.data.loop.cnt
   314 417D B1 CB		        lda (RAMIO.SECPTR),y
   315 417F 20 FA 41		        jsr convha
   316 4182 8A			        txa    ;save chars on stack
   317 4183 48			        pha
   318 4184 98			        tya
   319 4185 48			        pha
   320 				; set text and print line
   321 4186 AD AE 41		        lda print.data.loop.cnt
   322 4189 29 0F		        and #$0f
   323 418B 0A			        asl
   324 418C AA			        tax
   325 418D 68			        pla
   326 418E 9D AF 41		        sta print.data.line,x
   327 4191 E8			        inx
   328 4192 68			        pla
   329 4193 9D AF 41		        sta print.data.line,x
   330 4196 E0 1F		        cpx #$1f
   331 4198 D0 09		        bne print.data.loop.next
   332 419A A2 AF		        ldx #<print.data.line
   333 419C A0 41		        ldy #>print.data.line
   334 419E A9 21		        lda #print.data.line.end-print.data.line
   335 41A0 20 11 42		        jsr print
   336 41A3			print.data.loop.next
   337 				; increment and check
   338 41A3 EE AE 41		        inc print.data.loop.cnt
   339 41A6 A9 80		        lda #$80
   340 41A8 CD AE 41		        cmp print.data.loop.cnt
   341 41AB D0 CD		        bne print.data.loop
   342 				        
   343 41AD 60			        rts
   344
   345 41AE			print.data.loop.cnt
   346 41AE 00			        .byte $00        
   347 41AF			print.data.line
   348 41AF 23 23 23 23 23 23 + :16     .byte '##'
   349 41CF 9B			        .byte $9b
   350 41D0			print.data.line.end
   351
   352 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   353 				; 
   354 				; Print Sector
   355 				;
   356
   357 41D0			print.sector
   358 41D0 AD 0B 03		        lda DCBSEC+1    ;get high byte
   359 41D3 20 FA 41		        jsr convha
   360 41D6 8E F6 41		        stx print.sector.sec.num
   361 41D9 8C F7 41		        sty print.sector.sec.num+1
   362
   363 41DC AD 0A 03		        lda DCBSEC      ;get low byte
   364 41DF 20 FA 41		        jsr convha
   365 41E2 8E F8 41		        stx print.sector.sec.num+2
   366 41E5 8C F9 41		        sty print.sector.sec.num+3
   367
   368 41E8 A2 F2		        ldx #<print.sector.sec ; print
   369 41EA A0 41		        ldy #>print.sector.sec
   370 41EC A9 08		        lda #print.sector.sec.end-print.sector.sec
   371 41EE 20 11 42		        jsr print        
   372
   373 41F1 60			        rts
   374
   375 41F2			print.sector.sec
   376 41F2 1E 1E 1E 1E		:4      .byte $1e
   377 41F6			print.sector.sec.num
   378 41F6 58 58 58 58		        .byte 'XXXX'
   379 41FA			print.sector.sec.end
   380
   381 				        
   382 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   383 				; 
   384 				; Convert Hex to ATASCII
   385 				;
   386 				; IN    A    byte
   387 				; OUT X,Y    two ATASCII codes of hex representation
   388 				;
   389
   390 41FA			convha ; conv hex to atascii
   391 41FA 48			        pha                    
   392 41FB 4A			        lsr
   393 41FC 4A			        lsr
   394 41FD 4A			        lsr
   395 41FE 4A			        lsr
   396 41FF F8			        sed        
   397 4200 18			        clc
   398 4201 69 90		        adc #$90
   399 4203 69 40		        adc #$40
   400 4205 AA			        tax
   401 4206 68			        pla
   402 4207 29 0F		        and #$0f
   403 4209 18			        clc
   404 420A 69 90		        adc #$90
   405 420C 69 40		        adc #$40
   406 420E A8			        tay
   407 420F D8			        cld            
   408 4210 60			        rts
   409
   410
   411 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   412 				; 
   413 				; Print Message
   414 				;
   415 				; IN    X,Y    low, high byte of address to message
   416 				;        A    length of message
   417
   418 4211			print ; print message
   419 4211 8D 48 03		        sta IOCB.BUFLEN
   420 4214 A9 00		        lda #$00
   421 4216 8D 49 03		        sta IOCB.BUFLEN+1
   422 4219 8E 44 03		        stx IOCB.BUF
   423 421C 8C 45 03		        sty IOCB.BUF+1
   424 421F A9 0B		        lda #XIO.PUT
   425 4221 8D 42 03		        sta IOCB.CMD
   426 4224 A2 00		        ldx #$00
   427 4226 20 56 E4		        jsr CIOV
   428 4229 60			        rts
   429
   430 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   431 				; 
   432 				; Data for RAMIO 
   433 = 00CB			RAMIO.SECPTR = $cb      ; address to buffer
   434 422A			RAMIO.SECBUF            ; input read/write buffer
   435 422A EE EE EE EE EE EE + :$80    .byte $ee    
   436
   437 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   438 				; 
   439 				; Run address
   440 02E0-02E1> 00 40		        run start        ;Define run address
